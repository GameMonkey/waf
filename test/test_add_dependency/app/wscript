#! /usr/bin/env python
# encoding: utf-8

APPNAME = 'test_add_dependency'
VERSION = '1.0.0'

import os
import shutil

import waflib
from waflib.extras.wurf.wurf_git import WurfGit

def resolve(ctx):

    # Setup path to libraries for the fake git clone
    print(ctx.path)

    git_dir = ctx.path.parent.find_node('git_dir')
    foo_dir = git_dir.find_node('libfoo')

    libraries = {'github.com/acme-corp/foo.git': foo_dir.abspath()}

    class FakeGitClone(WurfGit):

        def __init__(self, git_binary, ctx, libraries):
            super(FakeGitClone, self).__init__(
                git_binary=git_binary, ctx=ctx)

            self.libraries = libraries

        def clone(self, repository, directory, cwd):
            print("repository={}".format(repository))
            print("directory={}".format(directory))
            print("cwd={}".format(cwd))

            print(self.libraries)
            
            dst_directory = os.path.join(cwd, directory)
            print("dst_directory={}".format(dst_directory))

            for lib_repository, lib_directory in self.libraries:
                if repository.endswidth(lib_directory):
                    shutil.copytree(src=lib_directory, dst=dst_directory)
                    return

            else:
                assert(0)

    def build_fake_git(registry):
        git_binary = registry.require('git_binary')
        ctx = registry.require('ctx')

        return FakeGitClone(git_binary=git_binary, ctx=ctx, libraries=libraries)


    # Get the registry and replace the git builder
    registry = ctx.registry
    registry.provide('git', build_fake_git)

    # Rebuild the dependency manager
    ctx.dependency_manager = registry.require('dependency_manager')

    ctx.add_dependency(
        name='foo',
        recurse=False,
        optional=False,
        resolver='git',
        method='checkout',
        checkout='1.3.3.7',
        sources=['github.com/acme-corp/foo.git'])

    # ctx.add_dependency(
    #     name='meta',
    #     recurse=False,
    #     optional=False,
    #     resolver='git',
    #     method='semver',
    #     major=1,
    #     sources=['github.com/steinwurf/meta.git'])


def options(opt):

    opt.load('compiler_cxx')

def configure(conf):
    conf.load('compiler_cxx')


def build(bld):

    bld.program(features='cxx',
                source='main.cpp',
                target='app')

    print(waflib.extras.wurf.wurf_resolve_context.dependency_cache)
    #print("PATH ", bld.dependency_path('waf'))
    #print("PATH ", bld.dependency_path('meta'))
