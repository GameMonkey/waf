#! /usr/bin/env python
# encoding: utf-8

APPNAME = 'test_add_dependency'
VERSION = '1.0.0'

import os
import shutil

import waflib
from waflib.extras.wurf.wurf_git import WurfGit

class CloneError(Exception):
    """Basic """
    def __init__(self, msg):
        super(CloneError, self).__init__(msg)


def resolve(ctx):

    # Setup path to libraries for the fake git clone
    print(ctx.path)

    git_dir = ctx.path.parent.find_node('git_dir')
    foo_dir = git_dir.find_node('libfoo')

    libraries = {'github.com/acme-corp/foo.git': foo_dir.abspath()}

    class FakeGitClone(WurfGit):

        def __init__(self, git_binary, ctx, libraries):
            super(FakeGitClone, self).__init__(
                git_binary=git_binary, ctx=ctx)

            self.libraries = libraries

        def clone(self, repository, directory, cwd):
            ctx.logger.debug("repository={}".format(repository))
            ctx.logger.debug("directory={}".format(directory))
            ctx.logger.debug("cwd={}".format(cwd))

            ctx.logger.debug(self.libraries)

            dst_directory = os.path.join(cwd, directory)
            ctx.logger.debug("dst_directory={}".format(dst_directory))

            for lib_repository, lib_directory in self.libraries.items():
                if repository.endswith(lib_repository):
                    shutil.copytree(src=lib_directory, dst=dst_directory)

                    assert os.path.isdir(dst_directory), "We should have a valid path here!"
                    return

            else:
                raise CloneError("No mapping for the repository found!")

    def build_fake_git(registry):
        git_binary = registry.require('git_binary')
        ctx = registry.require('ctx')

        return FakeGitClone(git_binary=git_binary, ctx=ctx, libraries=libraries)


    # Get the registry and replace the git builder
    registry = ctx.registry
    registry.provide('git', build_fake_git)

    # Rebuild the dependency manager
    ctx.dependency_manager = registry.require('dependency_manager')

    ctx.add_dependency(
        name='foo',
        recurse=True,
        optional=False,
        resolver='git',
        method='checkout',
        checkout='1.3.3.7',
        sources=['github.com/acme-corp/foo.git'])

    # ctx.add_dependency(
    #     name='meta',
    #     recurse=False,
    #     optional=False,
    #     resolver='git',
    #     method='semver',
    #     major=1,
    #     sources=['github.com/steinwurf/meta.git'])


def options(opt):

    opt.load('compiler_cxx')

def configure(conf):
    conf.load('compiler_cxx')


def build(bld):

    bld.program(features='cxx',
                source='main.cpp',
                target='app',
                use='foo')
                
    print("in build")

    print(waflib.extras.wurf.wurf_resolve_context.dependency_cache)
    #print("PATH ", bld.dependency_path('waf'))
    #print("PATH ", bld.dependency_path('meta'))
