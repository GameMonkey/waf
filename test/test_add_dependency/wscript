#! /usr/bin/env python
# encoding: utf-8

APPNAME = 'test_add_dependency'
VERSION = '1.0.0'

import mock
import os
import shutil

import waflib
from waflib.extras.wurf.wurf_git import WurfGit

def resolve(ctx):

    class FakeGitClone(WurfGit):
        
        def __init__(self, git_binary, ctx):
            super(FakeGitClone, self).__init__(
                git_binary=git_binary, ctx=ctx)
                
        def clone(self, repository, directory, cwd):
            
            super(FakeGitClone, self).clone(repository=repository,
                directory=directory, cwd=cwd)

    def build_fake_git(registry):
        git_binary = registry.require('git_binary')
        ctx = registry.require('ctx')
        
        return FakeGitClone(git_binary=git_binary, ctx=ctx)
        
    
        
    def okd():
        """ Mocking the resolve function which is the one called when
        fetching a dependency"""

        assert(source=='https://fake.com/libfoo.git')

        assert(0)

        shutil.copytree(src=path, dst=repo_path)

        return p

    # Get the registry and replace the git builder
    registry = ctx.registry
    registry.provide('git', build_fake_git)
    
    # Rebuild the dependency manager
    ctx.dependency_manager = registry.require('dependency_manager')

    ctx.add_dependency(
        name='waf',
        recurse=False,
        optional=False,
        resolver='git',
        method='checkout',
        checkout='waf-1.9.5',
        sources=['github.com/waf-project/waf.git'])
        
    ctx.add_dependency(
        name='meta',
        recurse=False,
        optional=False,
        resolver='git',
        method='semver',
        major=1,
        sources=['github.com/steinwurf/meta.git'])


def options(opt):

    pass

def configure(conf):
    pass


def build(bld):
    print(waflib.extras.wurf.wurf_resolve_context.dependency_cache)
    print("PATH ", bld.dependency_path('waf'))
    print("PATH ", bld.dependency_path('meta'))
